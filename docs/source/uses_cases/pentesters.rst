For Pentesters
==============

Track API Session and export to BurpSuite / OWASP ZAP
-----------------------------------------------------

Some times is useful store the browsing navigation for an specific API. Yes, you can do that using **BurpSuite**, **OWASP ZAP** or any other similar software.

But these software stores the navigation in their own format. You haven't a standard format where the navigation is stored.

``API-Check`` proxy stores the browsing navigation in a standard Relational database (MySQL, PostgresSQL, SQLite...) so you can:

- Find any information using standard SQL Syntax or using any DB Browser.
- Re-inject the stored traffic to another tool.

For this example we focus into the second case:

.. image:: /_static/images/reinject_to_security_tool.png

**1 - Launch the proxy**

To perform that we first must launch ``API-Check`` :doc:`proxy </tools/proxy>` an record a new session:

.. code-block:: console

    > at-proxy -C sqlite:///browsing_reinject.sqlite3

At proxy starts, it displays the **API Version ID** that automatically are generated for that browsing. You must keep it for next step.

When you finish browsing, then press :samp:`CTRL+C` to stop.

**2 - Send browsing data to security tool**

At this point ``API-Check`` was stored in the the **browsing_reinject.sqlite3** the session. Now, with the **API Version ID** we can re-inject the data to the security tool:

.. code-block:: console

    > ac-dbcat sqlite:///browsing_reinject.sqlite3 | at-sendto --proxy 127.0.0.1:9000


Tracking API versions
---------------------

``API-Check`` allows to track API Versions. It offers two ways to track them:

- Using Proxy: each time proxy starts creates a new unique version from domain and end-points. This version will be the same if the End-points and the server is the same.
- Using OpenAPI 3: You can load an API definition from OpenAPI 3. ``API-Check`` tracks the version from the definition version.

Once you have the definitions, ``API-Check`` permits check API versions and history.


.. image:: /_static/images/api_versions.png
   :align: center

To check the versions you can use action :samp:`apis` from :samp:`manage` tool:

.. code-block:: console

    > at-manage apis


Random fuzzing using OpenAPI definition
---------------------------------------

``API-Check`` can generate random data to specific API end-points, using OpenAPI 3 API definition.

For this example, we toke this API definition:

.. _api_definition:

.. image:: /_static/images/api_definition.png
   :align: center
   :scale: 80%

.. note::

    ``API-Check`` uses **Faker** to generate data. So, it support all of types of Faker. You can check `supported types here <https://faker.readthedocs.io/en/stable/providers.html>`_

We'll generate fuzzing values for end-point :samp:`/products/{productId}`

.. code-block:: yaml
   :linenos:
   :emphasize-lines: 11,16,19,23,28

    name: "my library api"
    description: "OpenAPI 3 fuzzing example"
    version: "0.9-RC"
    tags:
        - books
        - products
    global:
        headers:
            Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
    endpoints:
        /products/{productId}:
            pathParams:
                productId: 500
            post:
                body:
                    name:
                        type: string
                        maxLength: 40
                    price:
                        type: number
                        minimum: -10
                        maximum: 3000000
                    description:
                        type: string
                        format: random
                        minLength: 10000
                        maxLength: 20000
                    type:
                        type: dictionary
                        values:
                            - -1
                            - 0
                            - 1
                            - 100000000


SQL Injection attack check using API definition
-----------------------------------------------

As in the previous example, we can customize the data generation to perform attacks from API definition.

In this example, we'll use the the :ref:`same API definition <api_definition>` and we'll use SQL Injections from a dictionary file:

For the users *admin* and *root* we build the queries with injections from :samp:`sql_injections.txt` file.

.. code-block:: yaml
   :linenos:
   :emphasize-lines: 11,14,21

    name: "my library api"
    description: "SQL Injection example"
    version: "0.9-RC"
    tags:
        - books
        - users
    global:
        headers:
            Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
    endpoints:
        /{user}/search:
            pathParams:
                user:
                    type: dictionary
                    values:
                        - admin
                        - root
            post:
                body:
                    query:
                        type: file
                        file: sql_injections.txt


User Enumeration using API definition
-------------------------------------


Weak password check using parametrized fuzzing
----------------------------------------------

